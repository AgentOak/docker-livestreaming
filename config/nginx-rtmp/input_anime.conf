# Input for video with 23.976fps, 16:9 aspect and animation-like content and RTMP/DASH/HLS-compatible audio (usually AAC)
# Passed through to main live output (RTMP) and transcoded for adaptive formats (DASH/HLS)
# When using NTSC framerates such as 23.976fps segments generated in adaptive.conf will
#   automatically be sightly longer (2.002s), as specifications recommend
# You should copy this file to input_<name>.conf and adjust according to your content, framerate, etc.
#   Set -tune grain/film/animation, -r <framerate>, bitrates and others for ffmpeg below
application input_anime {
    include applications/include/input.conf;

    ### Example: pull stream from some other site, static to always pull, instead of only after first client
    #pull rtmp://example.com/live/mystream name=mystream live=1 static;

    # ffmpeg options
    #   -analyzeduration 12M means 12sec and is for arut/nginx-rtmp bug #405
    #     11sec is just long enough to ensure finding a keyframe with keyframe=250 @ 23.976 FPS
    #   -fflags nobuffer is to counteract the delay introduced by analyzeduration
    #   -max_muxing_queue_size 512 is for ffmpeg bug #6375. Might not be needed when also transcoding audio
    # (lib)x264 options
    #   -profile:v main is optional to support more clients (high is default)
    #   If you have a beefy CPU, try higher x264 presets for increased efficiency
    #   -vsync cfr and force-cfr force a constant framerate by dropping or duplicating input frames
    #     nal-hrd=cbr signals constant framerate to clients
    #   rc-lookahead=12 introduces half a second of latency for a total of ~2.5s encoder latency,
    #     -tune zerolatency eliminates encoder latency completely (and saves on CPU) but quality will suffer
    #     tremendously for a relatively minor improvement. (Most latency comes from DASH/HLS segment size)
    #   Adjust -crf and -maxrate according to your quality preference/bandwidth budget
    #   -g == -keyint_min determine segment size; <segment secs>=<g>/<fps>. Segment durations
    #     specified in adaptive.conf should be equal to or a multiple of <segment secs>
    #   For no reason at all, x264 limits min-keyint to keyint/2+1, so setting
    #     -keyint_min won't actually work (will be clipped to 48/2+1=25). This means x264 can't do
    #     fixed GOP sizes unless we disable scenecut (-sc_threshold 0) and lose I-frames within GOPs.
    #     There are patches for x264 found online that fix this behavior.
    #   -bufsize should be <segment secs>*<maxrate>,
    # For choice of profiles and levels see https://trac.ffmpeg.org/wiki/Encode/H.264#Compatibility
    exec ffmpeg -analyzeduration 12M -fflags nobuffer -sws_flags lanczos -i rtmp://localhost/$app/$name -pix_fmt yuv420p                    -threads 8 -c:v libx264 -profile:v high     -level 4   -r 23.976 -vsync cfr -preset veryfast -tune animation -x264-params rc-lookahead=12:nal-hrd=cbr:force-cfr -crf 20 -g 48 -keyint_min 48 -sc_threshold 0 -flags +cgop -maxrate 6500k -bufsize 13000k -c:a copy -max_muxing_queue_size 512 -f flv rtmp://localhost/segmented/$name_1080p;
    exec ffmpeg -analyzeduration 12M -fflags nobuffer -sws_flags lanczos -i rtmp://localhost/$app/$name -pix_fmt yuv420p -vf scale=1280:720 -threads 4 -c:v libx264 -profile:v main     -level 3.1 -r 23.976 -vsync cfr -preset veryfast -tune animation -x264-params rc-lookahead=12:nal-hrd=cbr:force-cfr -crf 19 -g 48 -keyint_min 48 -sc_threshold 0 -flags +cgop -maxrate 3500k -bufsize 7000k  -c:a copy -max_muxing_queue_size 512 -f flv rtmp://localhost/segmented/$name_720p;
    exec ffmpeg -analyzeduration 12M -fflags nobuffer -sws_flags lanczos -i rtmp://localhost/$app/$name -pix_fmt yuv420p -vf scale=854:480  -threads 4 -c:v libx264 -profile:v main     -level 3.1 -r 23.976 -vsync cfr -preset veryfast -tune animation -x264-params rc-lookahead=12:nal-hrd=cbr:force-cfr -crf 19 -g 48 -keyint_min 48 -sc_threshold 0 -flags +cgop -maxrate 1800k -bufsize 3600k  -c:a copy -max_muxing_queue_size 512 -f flv rtmp://localhost/segmented/$name_480p;
    # These are the garbage stream that basically all devices are compatible with and for bad connectivity (<=2mbps)
    exec ffmpeg -analyzeduration 12M -fflags nobuffer -sws_flags lanczos -i rtmp://localhost/$app/$name -pix_fmt yuv420p -vf scale=640:360  -threads 2 -c:v libx264 -profile:v baseline -level 3   -r 23.976 -vsync cfr -preset fast     -tune animation -x264-params rc-lookahead=12:nal-hrd=cbr:force-cfr -crf 18 -g 48 -keyint_min 48 -sc_threshold 0 -flags +cgop -maxrate 1100k -bufsize 2200k  -c:a copy -max_muxing_queue_size 512 -f flv rtmp://localhost/segmented/$name_360p;
    exec ffmpeg -analyzeduration 12M -fflags nobuffer -sws_flags lanczos -i rtmp://localhost/$app/$name -pix_fmt yuv420p -vf scale=480:270  -threads 2 -c:v libx264 -profile:v baseline -level 2.1 -r 23.976 -vsync cfr -preset fast     -tune animation -x264-params rc-lookahead=12:nal-hrd=cbr:force-cfr -crf 18 -g 48 -keyint_min 48 -sc_threshold 0 -flags +cgop -maxrate 600k  -bufsize 1200k  -c:a aac -ac 2 -b:a 96K -max_muxing_queue_size 512 -f flv rtmp://localhost/segmented/$name_270p;
    # TODO: Does rc-lookahead even introduce latency when using CGOPs? Try rc-lookahead=48 and compare
    # TODO: Multiple stream variants need to be in one ffmpeg instance
    # TODO: Log ffmpeg -hide_banner -nostats -loglevel warning to /dev/stderr.
}
